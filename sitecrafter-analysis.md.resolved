# ğŸ“‹ SiteCrafter Project - Complete Analysis

## ğŸ¯ Project Overview

**SiteCrafter** is an AI-powered website/application generator that creates complete, production-ready code for frontend, backend, and fullstack projects. It uses Gemini AI models to generate code based on user prompts and presents it through an interactive web interface.

## ğŸ—ï¸ Architecture Overview

```
website-builder/
â”œâ”€â”€ backend/          # Express.js API server with AI integration
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ index.ts                      # Main entry point with 8 API endpoints
â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â”œâ”€â”€ parser.utils.ts           # XML/JSON parsing for blueprints
â”‚   â”‚   â”‚   â”œâ”€â”€ backend-parser.ts         # Backend code analysis
â”‚   â”‚   â”‚   â”œâ”€â”€ geminiPool.ts             # AI model connection pooling
â”‚   â”‚   â”‚   â””â”€â”€ openai*.ts                # OpenAI wrapper for Gemini
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ planning-fixed.service.ts # Blueprint generation with LLM
â”‚   â”‚   â”‚   â”œâ”€â”€ ui.service.ts             # UI component selection
â”‚   â”‚   â”‚   â””â”€â”€ mem0.service.ts           # Memory/context storage
â”‚   â”‚   â”œâ”€â”€ prompts/                      # System prompts for code gen
â”‚   â”‚   â”œâ”€â”€ prompts.ts                    # 42KB+ comprehensive prompts
â”‚   â”‚   â”œâ”€â”€ constant.ts                   # Constants & XML tags
â”‚   â”‚   â””â”€â”€ ui/components.ts              # 234 UI component snippets
â”‚   â””â”€â”€ package.json 
â”œâ”€â”€ frontend/         # React + TypeScript UI
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ App.tsx                       # Routing (Home, Dashboard, Builder, Planning)
â”‚   â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”‚   â”œâ”€â”€ Builder.tsx               # Main code generation & display
â”‚   â”‚   â”‚   â”œâ”€â”€ Planning.tsx              # Blueprint visualization
â”‚   â”‚   â”‚   â”œâ”€â”€ ProjectTypeSelection.tsx  # Choose frontend/backend/fullstack
â”‚   â”‚   â”‚   â”œâ”€â”€ Dashboard.tsx             # User dashboard
â”‚   â”‚   â”‚   â”œâ”€â”€ Home.tsx                  # Landing page
â”‚   â”‚   â”‚   â”œâ”€â”€ Login.tsx & Register.tsx  # Authentication
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ FileExplorer.tsx          # File tree navigation
â”‚   â”‚   â”‚   â”œâ”€â”€ CodeEditor.tsx            # Monaco editor for code viewing/editing
â”‚   â”‚   â”‚   â”œâ”€â”€ PreviewFrame.tsx          # Live preview using WebContainer
â”‚   â”‚   â”‚   â”œâ”€â”€ StepsList.tsx             # Progress tracking
â”‚   â”‚   â”‚   â”œâ”€â”€ WorkflowCanvas.tsx        # Visual blueprint display (React Flow)
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â””â”€â”€ useWebContainer.ts        # WebContainer API integration
â”‚   â”‚   â”œâ”€â”€ steps.ts                      # XML parsing for file generation
â”‚   â”‚   â””â”€â”€ config.ts                     # Backend URL config
â”‚   â””â”€â”€ package.json
â””â”€â”€ generated_testing/  # Output directory for testing
```

---

## ğŸ”„ Complete Code Generation Flow

### Phase 1: User Input â†’ Planning Phase

1. **User Journey:**
   - User navigates to `/select` (ProjectTypeSelection page)
   - Selects project type: `frontend` | `backend` | `fullstack`
   - Enters prompt (e.g., "create a cake selling website")
   - Frontend navigates to `/planning` with prompt and projectType

2. **Planning API Call:**
   ```typescript
   POST /planning
   Body: { requirements: string, projectType: string }
   ```

3. **Backend Planning Service ([planning-fixed.service.ts](file:///c:/Users/Dell%20insprion/Videos/website-builder/backend/src/services/planning-fixed.service.ts)):**
   - Analyzes requirements & project type
   - Determines node count (30-40 nodes for production-level architecture)
   - Calls Gemini AI with specialized planning system prompt
   - LLM generates JSON blueprint with:
     * `projectName`, `description`
     * `techStack` (frontend/backend/database arrays)
     * `features` array
     * `workflow` with `nodes` and `edges`
     * `detailedContext` (8000+ words implementation guide)

4. **Blueprint Parsing ([parser.utils.ts](file:///c:/Users/Dell%20insprion/Videos/website-builder/backend/src/utils/parser.utils.ts)):**
   - Uses regex-based extraction (not JSON.parse)
   - Extracts workflow nodes, edges, features
   - Validates blueprint structure
   - Handles line breaks and formatting issues

5. **Frontend Display:**
   - Planning.tsx shows:
     * Project name, description
     * Nodes/edges/features count
     * Tech stack breakdown
     * Visual workflow canvas (React Flow)
   - User can **Approve** (continue to Builder) or **Start Over**

---

### Phase 2: Blueprint â†’ Code Generation

1. **User Approves Blueprint:**
   - Frontend extracts `detailedContext` from blueprint
   - Navigates to `/builder` with:
     ```javascript
     {
       prompt: blueprint.detailedContext,  // Detailed implementation guide
       originalRequirements: userPrompt,    // Original input
       blueprint: fullBlueprintObject       // Complete blueprint
     }
     ```

2. **Builder Initialization ([Builder.tsx](file:///c:/Users/Dell%20insprion/Videos/website-builder/frontend/src/pages/Builder.tsx)):**
   
   **For Frontend/Backend Projects:**
   ```typescript
   // Step 1: Get template
   POST /template
   Body: { prompt: originalRequirements, projectType: 'frontend'/'backend' }
   Response: { prompts: [], uiPrompts: [] }  // Base templates
   
   // Step 2: Generate code
   POST /chat
   Body: { messages: [
     { role: "user", content: BASE_PROMPT },
     { role: "user", content: TEMPLATE_CODE },
     { role: "user", content: detailedContext }  // From blueprint!
   ]}
   Response: { response: XML_CODE }  // XML with file instructions
   ```

   **For Fullstack Projects:**
   ```typescript
   POST /build/fullstack-complete
   Body: { 
     backendContext: blueprint.backendContext,
     frontendContext: blueprint.frontendContext,
     projectId: 'project_timestamp'
   }
   Response: { backend: XML_CODE, frontend: XML_CODE }
   ```

3. **XML Code Generation:**
   
   Backend uses **chirArtifact XML format**:
   ```xml
   <chirArtifact id="unique-id" title="Project Name">
     <chirAction type="shell">
       npm install
     </chirAction>
     <chirAction type="file" filePath="src/App.tsx">
       // File content here
     </chirAction>
     <!-- More chirActions... -->
   </chirArtifact>
   ```

---

### Phase 3: XML Parsing â†’ File Structure

1. **Frontend XML Parser ([steps.ts](file:///c:/Users/Dell%20insprion/Videos/website-builder/frontend/src/steps.ts)):**
   
   ```typescript
   function parseXml(xml: string): Step[] {
     // Extracts <chirAction> tags
     // Creates Step objects with:
     {
       id: number,
       title: string,
       description: string,
       type: 'CreateFile' | 'RunCommand',
       status: 'pending' | 'completed',
       path: string,        // e.g., "src/App.tsx"
       code: string         // File content
     }
   }
   ```

2. **File Structure Generation:**
   
   Builder.tsx processes steps into file tree:
   ```typescript
   useEffect(() => {
     // For each step with type 'CreateFile'
     // Parse path: "src/components/Button.tsx"
     // Create folder structure: src/ â†’ components/ â†’ Button.tsx
     // Store file content
     // Update files state
   }, [steps]);
   ```

3. **FileItem Structure:**
   ```typescript
   interface FileItem {
     name: string;         // "Button.tsx"
     type: 'file' | 'folder';
     path: string;         // "src/components/Button.tsx"
     content?: string;     // File content (if file)
     children?: FileItem[]; // Child items (if folder)
   }
   ```

---

### Phase 4: WebContainer Integration

1. **Mount Files to WebContainer:**
   ```typescript
   // Convert FileItem[] â†’ WebContainer mount structure
   const mountStructure = {
     'src': {
       directory: {
         'components': {
           directory: {
             'Button.tsx': { file: { contents: '...' } }
           }
         }
       }
     },
     'package.json': { file: { contents: '...' } }
   };
   
   webcontainer.mount(mountStructure);
   ```

2. **Live Preview:**
   - PreviewFrame.tsx creates iframe
   - WebContainer runs `npm install && npm run dev`
   - Vite dev server starts in-browser
   - Preview iframe displays live site

---

## ğŸ” XML Understanding & Role

### XML Format: chirAction

SiteCrafter uses a **custom XML schema** called **chirArtifact/chirAction**:

```xml
<chirArtifact id="project-id" title="Project Title">
  <!-- Shell commands -->
  <chirAction type="shell">
    npm install && npm run dev
  </chirAction>
  
  <!-- File creation -->
  <chirAction type="file" filePath="path/to/file.tsx">
    import React from 'react';
    
    export default function Component() {
      return <div>Hello</div>;
    }
  </chirAction>
</chirArtifact>
```

### Why XML?

1. **Structured Output:** Forces LLM to output organized, parseable code
2. **File Management:** Each `<chirAction>` = 1 file or 1 command
3. **Metadata:** Supports `filePath`, `type`, and other attributes
4. **Human Readable:** Easy to debug AI output
5. **Incremental Updates:** Can send follow-up prompts to modify specific files

### XML Parsing Strategy

**Backend generates â†’ Frontend parses â†’ WebContainer executes**

```
LLM generates XML â†’ parseXml() â†’ Step[] â†’ FileItem[] â†’ WebContainer
```

Two-step parsing:
1. **Regex extraction** ([parseXml](file:///c:/Users/Dell%20insprion/Videos/website-builder/frontend/src/steps.ts#3-95) in [steps.ts](file:///c:/Users/Dell%20insprion/Videos/website-builder/frontend/src/steps.ts)): Extract `<chirAction>` tags
2. **File tree building** ([Builder.tsx](file:///c:/Users/Dell%20insprion/Videos/website-builder/frontend/src/pages/Builder.tsx)): Convert flat steps â†’ nested file structure

---

## ğŸ“¡ API Endpoints Reference

### Backend ([index.ts](file:///c:/Users/Dell%20insprion/Videos/website-builder/backend/src/index.ts))

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/template` | POST | Get base templates (React/Node.js) for project type |
| `/chat` | POST | Send messages to LLM for code generation |
| `/planning` | POST | Generate project blueprint (Planning Phase) |
| `/build/fullstack-integrated` | POST | Generate fullstack with backend context shared |
| `/build/fullstack-complete` | POST | **Recommended**: Separate backend/frontend generation |
| `/build/separate` | POST | TEST: Generate backend + frontend independently |
| `/build/frontend-with-mem0` | POST | Generate frontend using Mem0 stored backend knowledge |
| `/test/mem0` | POST | Test Mem0 API connection |
| `/auth/*` | * | Authentication routes (Google OAuth, JWT) |

---

## ğŸ§© Key Components Deep Dive

### Backend: [index.ts](file:///c:/Users/Dell%20insprion/Videos/website-builder/backend/src/index.ts)

**8 Main API Endpoints:**

1. **`/template`** (Project initialization)
   - Returns base template code (React or Node.js)
   - Uses `reactprompt`, `nodeprompt`, or `COMPLETE_REACT_TEMPLATE`
   - Adds `QUALITY_REQUIREMENTS` for production-level code

2. **`/planning`** (Blueprint generation)
   - Calls `PlanningService.generateBlueprint()`
   - Returns JSON with nodes, edges, detailedContext
   - Used by Planning.tsx

3. **`/chat`** (Iterative code generation)
   - Receives array of messages (conversation history)
   - Adds production-level prompts
   - Returns XML code with file instructions
   - Handles follow-up modifications

4. **`/build/fullstack-complete`** (BEST approach)
   - Generates backend FIRST
   - Parses backend â†’ API specification
   - Generates frontend WITH backend knowledge
   - Returns `{ backend: XML, frontend: XML }`

5. **`/build/fullstack-integrated`**
   - Similar to complete but different strategy
   - Uses Mem0 for context storage

6. **`/build/separate`** (TEST mode)
   - Generates backend independently
   - Stores backend info in Mem0
   - Generates frontend using Mem0 knowledge

7. **`/build/frontend-with-mem0`**
   - Retrieves backend knowledge from Mem0
   - Generates frontend with API integration

8. **`/test/mem0`**
   - Tests Mem0 API connection
   - Used for debugging context storage

---

### Backend: [parser.utils.ts](file:///c:/Users/Dell%20insprion/Videos/website-builder/backend/src/utils/parser.utils.ts)

**OutputParser class** - Extracts project blueprint from LLM response:

```typescript
static extractProjectBlueprint(text: string): ProjectBlueprint | null {
  // 1. Extract basic fields (projectName, description)
  // 2. Extract techStack arrays
  // 3. Extract features array
  // 4. Extract workflow (nodes + edges) using regex
  // 5. Extract detailedContext as ONE continuous string
  // 6. Validate structure
  // 7. Return ProjectBlueprint object
}
```

**Why regex instead of JSON.parse?**
- LLMs often generate invalid JSON (trailing commas, line breaks in strings)
- Regex is more lenient and fault-tolerant
- Can handle formatting issues gracefully

---

### Backend: [backend-parser.ts](file:///c:/Users/Dell%20insprion/Videos/website-builder/backend/src/utils/backend-parser.ts)

**Analyzes generated backend code** to create API specification:

```typescript
parseBackendCode(code: string): BackendSpec {
  return {
    apiPrefix: '/api/v1',            // Extracted from app.use()
    endpoints: extractEndpoints(),    // Router definitions
    models: extractModels(),          // Mongoose schemas
    authentication: extractAuthInfo(), // JWT, bcrypt detection
    validation: extractValidationInfo(), // Zod/Joi
    features: extractFeatures()       // Detected libraries
  };
}
```

**Output: Human-readable API specification**
- TypeScript interfaces for models
- API endpoint documentation
- Integration examples
- Used for frontend generation

---

### Backend: [prompts.ts](file:///c:/Users/Dell%20insprion/Videos/website-builder/backend/src/prompts.ts)

**42KB+ file with comprehensive prompts!**

Key sections:
- **BASE_PROMPT**: Core instructions for production-ready code
- **getSystemPrompt()**: Complete system instructions (19,000+ words)
  * Design system requirements (colors, typography, layouts)
  * Mandatory features (animations, accessibility, SEO)
  * Package management (ZERO-ERROR guarantee)
  * Architecture principles (separation of concerns, TypeScript strict mode)
  * Special rules (NEVER use emojis, create multi-page apps always)

**Critical Concepts:**
- **Web-safe design system**: HSL colors, semantic tokens, responsive layouts
- **Intelligent feature inference**: Add features users didn't explicitly ask for
- **Production-first mindset**: Enterprise-grade, not tutorial-level
- **ZERO dependencies missing**: Scan all imports, add ALL to package.json

---

### Frontend: [Builder.tsx](file:///c:/Users/Dell%20insprion/Videos/website-builder/frontend/src/pages/Builder.tsx)

**Main code generation orchestrator:**

**State Management:**
```typescript
const [steps, setSteps] = useState<Step[]>([]);      // Parsed XML steps
const [files, setFiles] = useState<FileItem[]>([]);  // File tree
const [llmMessages, setLlmMessages] = useState([]);  // Conversation history
const [selectedFile, setSelectedFile] = useState();  // Currently viewed file
const [activeTab, setActiveTab] = useState();        // 'code' | 'preview'
```

**Key Functions:**
1. [init()](file:///c:/Users/Dell%20insprion/Videos/website-builder/frontend/src/pages/Builder.tsx#158-333): Initial code generation on page load
2. [parseXml()](file:///c:/Users/Dell%20insprion/Videos/website-builder/frontend/src/steps.ts#3-95): Convert XML â†’ Step[]
3. `useEffect()`: Convert Step[] â†’ FileItem[] (file tree)
4. `useEffect()`: Mount FileItem[] â†’ WebContainer
5. `handleCodeChange()`: Update file content when user edits

**Fullstack Handling:**
- Detects `blueprint.projectType === 'fullstack'`
- Calls `/build/fullstack-complete`
- Prefixes backend steps with `backend/`
- Prefixes frontend steps with `frontend/`
- Combines into single file tree

---

### Frontend: [Planning.tsx](file:///c:/Users/Dell%20insprion/Videos/website-builder/frontend/src/pages/Planning.tsx)

**Blueprint visualization and approval:**

**Three States:**
1. **input**: User enters requirements
2. **generating**: Calling backend `/planning` API
3. **review**: Display blueprint + workflow canvas

**WorkflowCanvas Integration:**
- Uses React Flow library
- Displays nodes (components/APIs/services)
- Shows edges (data flow/HTTP requests)
- Interactive visualization

**Approval Flow:**
```typescript
handleApprove() {
  const detailedPrompt = blueprint.detailedContext;
  navigate('/builder', { 
    state: { 
      prompt: detailedPrompt,  // 8000+ word implementation guide
      blueprint: blueprint 
    }
  });
}
```

---

### Frontend: [steps.ts](file:///c:/Users/Dell%20insprion/Videos/website-builder/frontend/src/steps.ts)

**XML Parser for chirAction format:**

```typescript
export function parseXml(xml: string): Step[] {
  const steps: Step[] = [];
  let stepId = 1;

  // Extract artifact title
  const titleMatch = xml.match(/<chirArtifact[^>]*title="([^"]+)"/);
  
  // Find all chirAction tags
  const actionRegex = /<chirAction[^>]*>/g;
  
  // For each action:
  for each chirAction {
    // Parse type attribute
    const type = match type="shell" or type="file"
    
    // Parse filePath attribute (if file)
    const filePath = extract from filePath="..."
    
    // Extract content between tags
    const content = text between <chirAction> and </chirAction>
    
    // Create Step object
    steps.push({
      id: stepId++,
      title: ...,
      type: 'CreateFile' or 'RunCommand',
      path: filePath,
      code: content
    });
  }
  
  return steps;
}
```

---

## ğŸ”§ Technology Stack

### Backend
- **Runtime**: Node.js + Express.js
- **Language**: TypeScript
- **AI**: Google Gemini (via OpenAI SDK wrapper)
- **Database**: MongoDB (for user data)
- **Auth**: Passport.js + Google OAuth + JWT
- **Memory**: Mem0 API (context storage)
- **Deployment**: Vercel Serverless

### Frontend
- **Framework**: React 19 + TypeScript
- **Build Tool**: Vite
- **Routing**: React Router DOM
- **Code Editor**: Monaco Editor
- **Execution**: WebContainer API (in-browser Node.js runtime)
- **Visualization**: React Flow (for workflow canvas)
- **Styling**: Tailwind CSS
- **Icons**: Lucide React
- **HTTP**: Axios
- **State**: React hooks (useState, useEffect)

---

## ğŸ¨ UI Component Library ([ui/components.ts](file:///c:/Users/Dell%20insprion/Videos/website-builder/backend/src/ui/components.ts))

**234 pre-built UI component snippets** organized by category:

Categories:
- **Text Animations** (22 components):
  * Split Text, Blur Text, Circular Text, Shuffle
  * Shiny Text, Text Pressure, Curved Loop
  * Fuzzy Text, Gradient Text, Text Cursor
  * Decrypted Text, True Focus, Rotating Text
  * Pixel Transition, Target Cursor, Laser Flow, etc.

- **Visual Effects** (15 components):
  * Gradual Blur, Click Spark, Metallic Paint
  * Image Trail, Splash Cursor, Meta Balls
  * Star Border, Animated List, Scroll Stack
  * Magic Bento, Circular Gallery, etc.

- **Navigation & Layout** (3 components):
  * Pill Nav, Dome Gallery, Chroma Grid

- **3D & Graphics** (5 components):
  * Model Viewer, Profile Card, Pixel Card
  * Dark Veil, Light Rays

- **Backgrounds** (12 components):
  * Color Bends, Aurora, Plasma, Particles
  * Galaxy, Threads, Hyperspeed
  * Grid Distortion, Ballpit, Orb

Each component includes:
- Description
- Code snippet (usage example)
- Dependencies (npm install command)

**Usage**: `UIService.selectComponents()` picks relevant components based on user prompt and injects them into the detailed context for code generation.

---

## ğŸ’¡ Key Insights & Design Decisions

### 1. **Why Planning Phase?**
- Gives users visibility into what will be generated
- Allows refinement before spending compute on code gen
- Visual workflow helps understand architecture
- Detailed context ensures comprehensive implementation

### 2. **Why XML Format?**
- Forces structured output from LLM
- Easy to parse with regex (fault-tolerant)
- Clear separation between files and commands
- Metadata support (filePath, type attributes)

### 3. **Why WebContainer?**
- Runs Node.js IN THE BROWSER (no cloud VM needed)
- Instant preview without deployment
- Secure sandbox environment
- npm install works directly in browser

### 4. **Why Separate Backend/Frontend Generation for Fullstack?**
- Avoids content filter issues (raw backend code triggers filters)
- Allows backend API spec extraction
- Frontend gets structured API documentation, not raw code
- Prevents context overflow (backend code can be 50KB+)

### 5. **Why Regex Parsing Instead of JSON.parse?**
- LLMs often generate invalid JSON
- Trailing commas, line breaks in strings, missing quotes
- Regex is lenient and extracts what matters
- Fallback mechanisms for partial failures

### 6. **Why Massive System Prompts (42KB)?**
- Ensures production-quality code
- Prevents common mistakes (missing dependencies, broken code)
- Enforces best practices (accessibility, SEO, responsive design)
- Reduces iterations by being comprehensive upfront

---

## ğŸš€ End-to-End Example: "Create a Cake Selling Website"

### Step 1: User Input
```
Page: /select
User: Selects "Frontend"
User: Types "create a cake selling website with product catalog and cart"
Action: Navigate to /planning
```

### Step 2: Planning API
```typescript
POST /planning
Body: { 
  requirements: "create a cake selling website...",
  projectType: "frontend"
}

Backend:
- PlanningService analyzes â†’ 35 nodes (multi-page frontend)
- Calls Gemini AI with planning prompt
- LLM generates blueprint with:
  * projectName: "Sweet Delights Bakery"
  * 35 workflow nodes (Home, Shop, Product Detail, Cart, Checkout pages)
  * 8000-word detailedContext with exact specifications

Response: { success: true, data: { blueprint: {...} } }
```

### Step 3: Blueprint Display
```
Page: /planning (review state)
Display:
- Project Name: "Sweet Delights Bakery"
- 35 Components, 45 Connections, 12 Features
- Tech Stack: React, TypeScript, Tailwind, Zustand
- Workflow Canvas: Visual node graph
User: Clicks "Approve & Start Coding"
```

### Step 4: Code Generation
```typescript
Navigate to: /builder
State: { 
  prompt: "SECTION 1: Complete File Structure... [8000 words]",
  originalRequirements: "create a cake selling website..."
}

Builder.tsx init():
POST /template â†’ Get React base template
POST /chat â†’ Generate code with detailedContext

Response: "<chirArtifact>
  <chirAction type="file" filePath="src/App.tsx">...</chirAction>
  <chirAction type="file" filePath="src/index.css">...</chirAction>
  ...
  <chirAction type="file" filePath="src/pages/Home.tsx">...</chirAction>
  <chirAction type="file" filePath="src/components/ProductCard.tsx">...</chirAction>
  ...
</chirArtifact>"
```

### Step 5: File Structure Creation
```typescript
parseXml(response) â†’ [
  { id: 1, type: 'CreateFile', path: 'src/App.tsx', code: '...' },
  { id: 2, type: 'CreateFile', path: 'src/index.css', code: '...' },
  ...
]

Convert to FileItem[]:
[
  { name: 'src', type: 'folder', children: [
    { name: 'App.tsx', type: 'file', content: '...' },
    { name: 'index.css', type: 'file', content: '...' },
    { name: 'pages', type: 'folder', children: [...] },
    { name: 'components', type: 'folder', children: [...] }
  ]},
  { name: 'package.json', type: 'file', content: '...' }
]
```

### Step 6: Live Preview
```typescript
webcontainer.mount(mountStructure);
webcontainer.spawn('npm', ['install']);
webcontainer.spawn('npm', ['run', 'dev']);
â†’ Vite dev server starts at http://localhost:5173
â†’ PreviewFrame iframe shows live website
â†’ User sees fully functional cake website with:
  * Animated hero section with cake images
  * Product grid with 12 cake cards
  * Working cart (add/remove items)
  * Responsive mobile design
  * Beautiful gradients and animations
```

---

## ğŸ¯ Summary

**SiteCrafter Flow:**
```
User Prompt â†’ Planning API â†’ Blueprint Generation â†’ Visual Canvas â†’ 
User Approval â†’ Template API â†’ Chat/Build API â†’ XML Code â†’ 
Parse XML â†’ File Tree â†’ WebContainer â†’ Live Preview
```

**Core Technologies:**
- **AI**: Gemini 2.5 Flash/Pro for code generation
- **Format**: Custom XML (chirArtifact/chirAction) for structured output
- **Parsing**: Regex-based (fault-tolerant) â†’ File tree
- **Execution**: WebContainer (in-browser Node.js)
- **Frontend**: React + TypeScript + Vite
- **Backend**: Express + TypeScript + MongoDB

**Key Files:**
- [backend/src/index.ts](file:///c:/Users/Dell%20insprion/Videos/website-builder/backend/src/index.ts): 8 API endpoints
- [backend/src/prompts.ts](file:///c:/Users/Dell%20insprion/Videos/website-builder/backend/src/prompts.ts): 42KB production-level prompts
- [backend/src/utils/parser.utils.ts](file:///c:/Users/Dell%20insprion/Videos/website-builder/backend/src/utils/parser.utils.ts): Blueprint extraction
- [backend/src/services/planning-fixed.service.ts](file:///c:/Users/Dell%20insprion/Videos/website-builder/backend/src/services/planning-fixed.service.ts): Blueprint generation
- [frontend/src/pages/Builder.tsx](file:///c:/Users/Dell%20insprion/Videos/website-builder/frontend/src/pages/Builder.tsx): Code generation orchestrator
- [frontend/src/pages/Planning.tsx](file:///c:/Users/Dell%20insprion/Videos/website-builder/frontend/src/pages/Planning.tsx): Blueprint visualization
- [frontend/src/steps.ts](file:///c:/Users/Dell%20insprion/Videos/website-builder/frontend/src/steps.ts): XML parsing

**The Magic:**
SiteCrafter combines AI code generation with a custom XML format and in-browser execution to create a seamless, production-ready code generation experience without requiring cloud deployment or complex setups.
